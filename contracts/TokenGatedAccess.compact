// SPDX-License-Identifier: MIT
// TokenGatedAccess.compact - Demonstrating ledger-based multi-factor gating
pragma language_version >= 0.17.0;

import CompactStandardLibrary;

module TokenGatedAccess {
    // Ledger for token balances.
    export ledger tokenBalances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<64>>;
    // Ledger storing a commitment (e.g., a hash of an access code).
    export ledger accessCommitments: Map<Either<ZswapCoinPublicKey, ContractAddress>, Bytes<32>>;

    // Helper: Get token balance
    circuit getTokenBalance(address: Either<ZswapCoinPublicKey, ContractAddress>): Uint<64> {
        if (tokenBalances.member(disclose(address))) {
            return tokenBalances.lookup(disclose(address));
        }
        return 0;
    }
    
    // Helper: Check if commitment exists
    circuit hasValidCommitment(address: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
        return accessCommitments.member(disclose(address));
    }

    // Core Verification: Prove you have tokens AND know the secret.
    export circuit verifyAccess(
        // Public Inputs:
        userAddress: Either<ZswapCoinPublicKey, ContractAddress>,
        requiredTokens: Uint<64>,
        // Private Witnesses:
        userSecret: Field,       // Proves control of `userAddress`
        codeSecret: Field        // Secret that corresponds to the on-chain commitment
    ): Boolean {
        // Verify both conditions directly without intermediate variables
        return getTokenBalance(userAddress) >= requiredTokens && 
               hasValidCommitment(userAddress);
    }
}




